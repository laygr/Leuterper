options{ STATIC = false;  }

PARSER_BEGIN(TheParser)

  using System;
  using System.IO;
  using System.Collections.Generic;
  using Leuterper;
  using Leuterper.Constructions;
  using Leuterper.Exceptions;

  // A few nested classes to make things simpler
  class TheParser{
    
  }

PARSER_END(TheParser)

public Program parse_Program() :
{
	List<LClass> classes = new List<LClass>();
	List<Function> functions = new List<Function>();
	List<IAction> actions = new List<IAction>();
}
{
	parse_Classes(classes);
	parse_Functions(functions);
	parse_IActions(actions);

	{ return new Program(classes, functions, actions); }
}

public Definition_Function parse_Definition_Function() :
{
	LType type;
	Token id;
	List<Declaration_Parameter> parameters = new List<Declaration_Parameter>();
	List<IAction> actions = new List<IAction>();
}
{
	type = parse_LType()
	id = parse_SID()
	<LP>
	parse_Parameters(parameters)
	<RP>
	<LC>
	parse_IActions(actions)
	<RC>
	{ return new Definition_Function(id.beginLine, type, id.image, parameters, actions); }
}

public Definition_Class parse_Definition_Class() :
{
	LType type;
	LType declarationInheritance = null;
	List<Declaration_Attribute> attributesDeclarations = new List<Declaration_Attribute>();
	List<Class_Procedure> classProcedures = new List<Class_Procedure>();
	Token c;
}
{
	c = <CLASS>
	type = parse_LType()
	[declarationInheritance = parse_Declaration_Inheritance()]
	<LC>
	parse_Declaration_Attributes(attributesDeclarations)
	parse_Class_Procedures(classProcedures)
	<RC>
	{ return new Definition_Class(c.beginLine, type, declarationInheritance, attributesDeclarations, classProcedures); }
}

public void parse_Class_Procedures(List<Class_Procedure> classProcedures) :
{
	Class_Procedure classProcedure;
}
{
	(
		LOOKAHEAD(parse_Definition_Method())
		classProcedure = parse_Definition_Method() { classProcedures.Add(classProcedure); }
		|
		classProcedure = parse_Definition_Constructor() { classProcedures.Add(classProcedure); }
	)*
}

public Definition_Constructor parse_Definition_Constructor() :
{
	Token id;
	List<Declaration_Parameter> parameters = new List<Declaration_Parameter>();
	List<IAction> actions = new List<IAction>();
}
{
	id = parse_BID()
	<LP>
	parse_Parameters(parameters)
	<RP>
	<LC>
	parse_IActions(actions)
	<RC>
	{ return new Definition_Constructor(id.beginLine, id.image, parameters, actions); }
}

public Definition_Method parse_Definition_Method() :
{
	LType type = null;
	Token id;
	List<Declaration_Parameter> parameters = new List<Declaration_Parameter>();
	List<IAction> actions = new List<IAction>();
}
{

	type = parse_LType()
	(
		id = parse_BID()
	|
		id = <SYMBOLS>
	)
	
	<LP>
	parse_Parameters(parameters)
	<RP>
	<LC>
	parse_IActions(actions)
	<RC>
	{ return new Definition_Method(id.beginLine, type, id.image, parameters, actions); }
}

public LType parse_Declaration_Inheritance() :
{
	LType type;
	Token inh;
}
{
	inh = <INH>
	type = parse_LType()
	{ return type; }
}

public void parse_Declaration_Attributes(List<Declaration_Attribute> attributesDeclarations) :
{
	Declaration_Attribute attributeDeclaration;
}
{
	(
		LOOKAHEAD(parse_Declaration_Attribute())
		attributeDeclaration = parse_Declaration_Attribute() { attributesDeclarations.Add(attributeDeclaration); }
	)*
}

public Declaration_Attribute parse_Declaration_Attribute() :
{
	LType type;
	Token id;
	Expression expression;
}
{
	type = parse_LType()
	id = parse_SID()
	<SC>
	{ return new Declaration_Attribute(id.beginLine, type, id.image); }
}

public Declaration_Var parse_Declaration_Var() :
{
	LType type;
	Token id;
	Expression expression;
}
{
	type = parse_LType()
	id = parse_SID()
	(
		<ASS>
		expression = parse_Expression()
		<SC>
		{ return new Declaration_Var(id.beginLine, type, id.image, expression); }
		|
		<SC>
		{ return new Declaration_Var(id.beginLine, type, id.image); }
	)
}

public Token parse_BID() :
{
	Token id;
}
{
	id = <BID>
	{
		return id;
	}
}

public Token parse_SID() :
{
	Token id;
}
{
	id = <SID>
	{
		return id;
	}
}

public Assignment parse_Assignment() :
{
	VarAccess lhs;
	Expression rhs;
	Token ass;
}
{
	lhs = parse_VarAccess()
	ass = <ASS>
	rhs = parse_Expression()
	{ return new Assignment(ass.beginLine, lhs, rhs); }
}

public Statement parse_IAction() :
{
	Statement action;
}
{
	(
		LOOKAHEAD(parse_LSet())
		(
			action = parse_LSet() <SC>
		)
		|
		LOOKAHEAD(parse_Assignment())
		(
			action = parse_Assignment() <SC>
		)
		|
		(
			action = parse_Expression() <SC>
		)
		|
		(
			action = parse_Conditional()
		)
		|
		(
			action = parse_Return_From_Block() <SC>
		)
	)

	{ return action; }
}

public Return_From_Block parse_Return_From_Block() :
{
	Expression returningExpression;
	Token rin;
}
{
	rin = <RTN>
	returningExpression = parse_Expression()
	{ return new Return_From_Block(rin.beginLine, returningExpression); }
}

public void parse_Arguments(List<Expression> arguments) :
{
	Expression expression;	
}
{
	[
		expression = parse_Expression() { arguments.Add(expression); }
		(
			<COMMA>
			expression = parse_Expression() { arguments.Add(expression); }
		)*
	]
}

public Expression parse_Expression() :
{
	Expression result;
}
{
	(
		LOOKAHEAD(parse_CExpression())
		result = parse_CExpression()
		|
		result = parse_GExpression()
	)
	{ return result; }
}

public Expression parse_GExpression() :
{
	Expression expression;
}
{
	(
		LOOKAHEAD(parse_Call_Function())
		(
			expression = parse_Call_Function()
		)
		|
			expression = parse_Call_Constructor()
		|
		LOOKAHEAD(parse_Term())
		(
			expression = parse_Term()
		)
		|
		(
			<LP>
			expression = parse_Expression()
			<RP>
		)
		|
		(
			expression = parse_Null()
		)
	)
	{ return expression; }
}

public Expression parse_CExpression() :
{
	Expression ground;
}
{
	ground = parse_GExpression()
	(
		(
			LOOKAHEAD(parse_Call_Method(ground))
			ground = parse_Call_Method(ground)
			|
			ground = parse_AttributeAccess(ground)
		)
	)+
	{ return ground; }
}

public AttributeAccess parse_AAExpression() :
{
	Expression ground;
}
{
	ground = parse_GExpression()
	(
		(
			LOOKAHEAD(parse_Call_Method(ground))
			(
				ground = parse_Call_Method(ground)
				ground = parse_AttributeAccess(ground)
			)
			|
			ground = parse_AttributeAccess(ground)
		)
	)+
	{ return (AttributeAccess) ground; }
}

public LSet parse_LSet() :
{
	AttributeAccess lhs;
	Expression rhs;
}
{
	lhs = parse_AAExpression()
	<ASS>
	rhs = parse_Expression()
	{ return new LSet(lhs.getLine(), lhs, rhs); }
}

public AttributeAccess parse_AttributeAccess(Expression theObject) :
{
	
	Token attributeName;
}
{
	<DOT>
	attributeName = parse_SID() {  return new AttributeAccess(attributeName.beginLine, theObject, attributeName.image); }
}

public Call_Function parse_Call_Function() :
{
	Token id;
	List<Expression> arguments = new List<Expression>();
}
{
	id = parse_SID()
	<LP>
	parse_Arguments(arguments)
	<RP>

	{ return new Call_Function(id.beginLine, id.image, arguments); }
}

public Call_Method parse_Call_Method(Expression theObject) :
{
	Token methodId;
	List<Expression> arguments = new List<Expression>();
	Expression expression;
}
{
	(
		(
			<DOT>
			methodId = parse_SID()
			<LP>
			parse_Arguments(arguments)
			<RP>
		)
		|
		(
			methodId = <SYMBOLS>
			expression = parse_Expression() { arguments.Add(expression); }
		)
	)

	{ return new Call_Method(methodId.beginLine, theObject, methodId.image, arguments); }
}

public Term parse_Term() :
{
	Term term;
}
{
	(
		LOOKAHEAD(parse_VarAccess())
		term = parse_VarAccess()
		|
		term = parse_LObject()
	)

	{ return term; }
}

public VarAccess parse_VarAccess() :
{
	Token id;
}
{
	id = parse_SID() { return new VarAccess(id.beginLine, id.image); }
}

public Call_Constructor parse_Call_Constructor() :
{
	LType type;
	List<Expression> arguments = new List<Expression>();
}
{
	<NEW>
	type = parse_LType()
	<LP>
	parse_Arguments(arguments)
	<RP>
	{ return new Call_Constructor(type.getLine(), type, arguments); }
}

public LObject parse_LObject() :
{
	LObject theObject;
}
{
	(
	theObject = parse_LNumber()
	|
	theObject = parse_LString()
	|
	theObject = parse_LChar()
	|
	theObject = parse_LList()
	|
	theObject = parse_LBoolean()
	)

	{ return theObject; }
}

public LNumber parse_LNumber() :
{
	Token theNumber;
	Token sign = null;
}
{

	(
		LOOKAHEAD(<S> <NUMBER>)
		sign = <S>
	)?
	theNumber = <NUMBER> { return new LNumber(theNumber.beginLine, sign, theNumber.image); }
}

public LChar parse_LChar() :
{
	Token aChar;
}
{
	aChar = <CHAR> { return new LChar(aChar.beginLine, aChar.image); }
}

public LString parse_LString() :
{
	Token aString;
}
{
	aString = <STRING> { return new LString(aString.beginLine, aString.image); }
}

public LBoolean parse_LBoolean() :
{
	Token boolean;
}
{
	boolean = <BOOL> { return new LBoolean(boolean.beginLine, boolean.image); }
}

public LList parse_LList() :
{
	LType type;
	List<Expression> elements = new List<Expression>() ;
	Token lb;
}
{
	
	lc = <LB>
	parse_Arguments(elements)
	<RB>
	<C>
	type = parse_LType()
	{ return new LList(lb.beginLine, type, elements); }
}

public Loop_Do_While parse_Loop_Do_While() :
{
	List<IAction> actions = new List<IAction>();
	Expression expression;
	Token ldo;
}
{
	ldo = <DO>
	<LC>
	parse_IActions(actions)
	<RC>
	<WHILE>
	expression = parse_Expression()
	<SC>
	{ return new Loop_Do_While(ldo.beginLine, expression, actions); }
}

public void parse_IActions(List<IAction> actions) :
{
	IAction action;
}
{
	(
		action = parse_IAction() { actions.Add(action); }
	)*
}

public Loop_While parse_Loop_While() :
{
	Expression expression;
	List<IAction> actions = new List<IAction>();
	Token lwhile;
}
{
	lwhile = <WHILE>
	expression = parse_Expression()
	<LC>
	parse_IActions(actions)
	<RC>
	{ return new Loop_While(lwhile.beginLine, expression, actions); }
}

public Conditional parse_Conditional() :
{
	Conditional conditional;
}
{
	(
		conditional = parse_If_Then_Else()
		|
		conditional = parse_Loop_While()
		|
		conditional = parse_Loop_Do_While()
	)
	{ return conditional; }
}

public If_Then_Else parse_If_Then_Else() :
{
	Expression expression;
	List<IAction> thenIActions = new List<IAction>();
	List<IAction> elseIActions = new List<IAction>();
	Token lif;
}
{
	lif = <IF>
	expression = parse_Expression()
	<LC>
	parse_IActions(thenIActions)
	<RC>
	[
		<ELSE>
		<LC>
		parse_IActions(elseIActions)
		<RC>
	]

	{ return new If_Then_Else(lif.beginLine, expression, thenIActions, elseIActions); }
}

public void parse_Parameters(List<Declaration_Parameter> parameters) :
{
	Declaratino_Parameter parameter;
}
{
	[
		parameter = parse_Parameter() { parameters.Add(parameter); }
		(
			<COMMA>
			parameter = parse_Parameter() { parameters.Add(parameter); }
		)*
	]
}

public LVoid parse_Null() :
{
	Token lnull;
}
{
	lnull = <NULL> { return new LVoid(lnull.beginLine); }
}


public Declaration_Parameter parse_Parameter() :
{
	LType type;
	Token id;
}
{
	type = parse_LType()
	id = parse_SID()
	{ return new Declaration_Parameter(id.beginLine, type, id.image); }	
}

public LType parse_LType() :
{
	Token id;
	List<LType> typeVariables = new List<LType>();
}
{
	id = parse_BID()
	[
		<LB>
		parse_LTypes(typeVariables)
		<RB>
	]
	{ return new LType(id.beginLine, id.image, typeVariables); }
}

public void parse_LTypes(List<LType> types) :
{
	LType type;
}
{
	[
		type = parse_LType() { types.Add(type); }
		(
			<COMMA>
			type = parse_LType() { types.Add(type); }
		)*
	]
}

public void parse_Statements(List<Statement> statements) :
{
	Statement statement;
}
{
	(
		statement = parse_Statement() { statements.Add(statement); }
	)*

}

public Statement parse_Statement() :
{
	Statement statement;
}
{

	(	
		statement = parse_Definition_Class()
		|
		LOOKAHEAD(parse_Definition_Function())
		statement = parse_Definition_Function()
		|
		statement = parse_Declaration_Var()
		|
		statement = parse_IAction()
	)
	{ return statement; }
}

// Lexer Definitions
SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" }
SKIP : { <"//" (~["\n","\r"])* ("\n" | "\r\n")> }
SKIP : { <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">}

TOKEN :
{
	<LC: "{">
	|
	<RC: "}">
	|
	<LP: "(">
	|
	<RP: ")">
	|
	<LB: "[">
	|
	<RB: "]">
	|
	<ASS: "=">
	|
	<C: ":">
	|
	<SC: ";">
	|
	<COMMA: ",">
	|
	<DOT: ".">
	|
	<CLASS: "class">
	|
	<DO: "do">
	|
	<ELSE: "else">
	|
	<INH: "inherits">
	|
	<IF: "if">
	|
	<NULL: "null">
	|
	<NEW: "new">
	|
	<RTN: "return">
	|
	<WHILE: "while">
	|
	<BOOL: ("true" | "false")>
	|
	<NUMBER: (<D>)+ ("\\."<D>)? >
}

TOKEN :
{
	<BID: <BL>(<L>|<D>)*>
	|
	<SID: <SL>(<L>|<D>)* >
	|
	< SYMBOLS: (<S>)+ >
}

TOKEN :
{
	<D: ["0"-"9"]>
	|
	<L: ["a"-"z","A"-"Z","_"]>
	|
	<BL: ["A"-"Z"]>
	|
	<SL: ["a"-"z"]>
	|
	<S: ("==" | "+" | "-" | "*" | "/" | "!" | "#" | "%" | "&" | "?" | "|" | "<" | ">")>
	|
	<CHAR: "'" ( ("\\" ~[]) | ( ~["'"] )) "'">
	|
	<STRING: "\"" ("\\" ~[] | (~["\""]) )* "\"" >
}